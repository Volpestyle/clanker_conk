import { spawn } from "node:child_process";
import { clampInt } from "./normalization/numbers.ts";
import { safeJsonParseFromString } from "./normalization/valueParsers.ts";

type ClaudeCliResult = {
  stdout: string;
  stderr: string;
};

type ClaudeCliError = Error & {
  killed?: boolean;
  signal?: string | null;
  code?: number | null;
  stdout?: string;
  stderr?: string;
};

type ClaudeCliStreamJob = {
  input: string;
  timeoutMs: number;
  stdout: string;
  stderr: string;
  stdoutBytes: number;
  stderrBytes: number;
  timedOut: boolean;
  timeout: ReturnType<typeof setTimeout> | null;
  resolve: (result: ClaudeCliResult) => void;
  reject: (error: Error) => void;
};

export type ClaudeCliStreamSessionLike = {
  run: (payload: { input?: string; timeoutMs?: number }) => Promise<ClaudeCliResult>;
  close: () => void;
  isIdle: () => boolean;
};

export function safeJsonParse(value, fallback = null) {
  return safeJsonParseFromString(value, fallback);
}

export function runClaudeCli({ args, input, timeoutMs, maxBufferBytes }) {
  return new Promise<ClaudeCliResult>((resolve, reject) => {
    const child = spawn("claude", args, { stdio: ["pipe", "pipe", "pipe"] });
    let stdout = "";
    let stderr = "";
    let stdoutBytes = 0;
    let stderrBytes = 0;
    let settled = false;
    let timedOut = false;

    const finish = (error: Error | null, result?: ClaudeCliResult) => {
      if (settled) return;
      settled = true;
      clearTimeout(timeout);
      if (error) reject(error);
      else resolve(result || { stdout: "", stderr: "" });
    };

    const timeout = setTimeout(() => {
      timedOut = true;
      try {
        child.kill("SIGTERM");
      } catch {}
      setTimeout(() => {
        if (settled) return;
        try {
          child.kill("SIGKILL");
        } catch {}
      }, 1000);
    }, timeoutMs);

    child.on("error", (error) => finish(error));

    child.stdout.on("data", (chunk) => {
      const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk || ""));
      if (stdoutBytes < maxBufferBytes) {
        const remaining = maxBufferBytes - stdoutBytes;
        stdout += buffer.subarray(0, remaining).toString("utf8");
      }
      stdoutBytes += buffer.length;
    });

    child.stderr.on("data", (chunk) => {
      const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk || ""));
      if (stderrBytes < maxBufferBytes) {
        const remaining = maxBufferBytes - stderrBytes;
        stderr += buffer.subarray(0, remaining).toString("utf8");
      }
      stderrBytes += buffer.length;
    });

    child.on("close", (code, signal) => {
      if (timedOut) {
        const error = new Error("claude CLI timeout") as ClaudeCliError;
        error.killed = true;
        error.signal = signal || "SIGTERM";
        error.code = code;
        error.stdout = stdout;
        error.stderr = stderr;
        finish(error, undefined);
        return;
      }

      if (code === 0) {
        finish(null, { stdout, stderr });
        return;
      }

      const error = new Error(`Command failed: claude ${args.join(" ")}`) as ClaudeCliError;
      error.code = code;
      error.signal = signal;
      error.stdout = stdout;
      error.stderr = stderr;
      finish(error, undefined);
    });

    child.stdin.on("error", () => {});
    child.stdin.end(input || "");
  });
}

function appendLimitedText(job: ClaudeCliStreamJob, channel: "stdout" | "stderr", textChunk: string, maxBufferBytes: number) {
  const normalizedChunk = String(textChunk || "");
  if (!normalizedChunk) return;
  const chunkBuffer = Buffer.from(normalizedChunk, "utf8");
  const chunkLength = chunkBuffer.length;

  if (channel === "stdout") {
    if (job.stdoutBytes < maxBufferBytes) {
      const remaining = maxBufferBytes - job.stdoutBytes;
      job.stdout += chunkBuffer.subarray(0, remaining).toString("utf8");
    }
    job.stdoutBytes += chunkLength;
    return;
  }

  if (job.stderrBytes < maxBufferBytes) {
    const remaining = maxBufferBytes - job.stderrBytes;
    job.stderr += chunkBuffer.subarray(0, remaining).toString("utf8");
  }
  job.stderrBytes += chunkLength;
}

function buildClaudeCliCommandError({
  args,
  code,
  signal,
  timedOut = false,
  stdout = "",
  stderr = ""
}: {
  args: string[];
  code?: number | null;
  signal?: string | null;
  timedOut?: boolean;
  stdout?: string;
  stderr?: string;
}) {
  const error = new Error(
    timedOut ? "claude CLI timeout" : `Command failed: claude ${Array.isArray(args) ? args.join(" ") : ""}`
  ) as ClaudeCliError;
  error.killed = Boolean(timedOut);
  error.signal = signal ?? null;
  error.code = typeof code === "number" ? code : code ?? null;
  error.stdout = String(stdout || "");
  error.stderr = String(stderr || "");
  return error;
}

class ClaudeCliStreamSession {
  args: string[];
  maxBufferBytes: number;
  child: ReturnType<typeof spawn> | null;
  queue: ClaudeCliStreamJob[];
  activeJob: ClaudeCliStreamJob | null;
  stdoutRemainder: string;
  closed: boolean;
  lastUsedAt: number;

  constructor({ args, maxBufferBytes }: { args: string[]; maxBufferBytes: number }) {
    this.args = Array.isArray(args) ? [...args] : [];
    this.maxBufferBytes = Math.max(4096, Math.floor(Number(maxBufferBytes) || 1024 * 1024));
    this.child = null;
    this.queue = [];
    this.activeJob = null;
    this.stdoutRemainder = "";
    this.closed = false;
    this.lastUsedAt = Date.now();
  }

  isIdle() {
    return !this.activeJob && this.queue.length === 0;
  }

  async run({ input = "", timeoutMs = 30_000 }: { input?: string; timeoutMs?: number }) {
    if (this.closed) {
      throw new Error("claude-code session is closed");
    }

    return await new Promise<ClaudeCliResult>((resolve, reject) => {
      this.queue.push({
        input: String(input || ""),
        timeoutMs: Math.max(1, Math.floor(Number(timeoutMs) || 30_000)),
        stdout: "",
        stderr: "",
        stdoutBytes: 0,
        stderrBytes: 0,
        timedOut: false,
        timeout: null,
        resolve,
        reject
      });
      this.pump();
    });
  }

  close() {
    this.closed = true;
    const queuedError = new Error("claude-code session closed");
    for (const job of this.queue.splice(0)) {
      job.reject(queuedError);
    }
    if (this.activeJob) {
      this.failActiveJob(queuedError);
    }
    this.terminateChild();
  }

  private pump() {
    if (this.closed) return;
    if (this.activeJob) return;
    if (!this.queue.length) return;

    this.ensureChild();
    if (!this.child) return;

    const nextJob = this.queue.shift() || null;
    if (!nextJob) return;

    this.activeJob = nextJob;
    this.lastUsedAt = Date.now();
    nextJob.timeout = setTimeout(() => {
      nextJob.timedOut = true;
      this.terminateChild();
    }, nextJob.timeoutMs);

    try {
      this.child.stdin.write(nextJob.input);
    } catch (error) {
      this.failActiveJob(error);
      this.pump();
    }
  }

  private ensureChild() {
    if (this.child) return;
    this.stdoutRemainder = "";

    const child = spawn("claude", this.args, { stdio: ["pipe", "pipe", "pipe"] });
    this.child = child;

    child.stdout.on("data", (chunk) => this.handleStdoutChunk(chunk));
    child.stderr.on("data", (chunk) => this.handleStderrChunk(chunk));
    child.on("error", (error) => {
      this.terminateChild();
      this.failActiveJob(error);
      this.pump();
    });
    child.on("close", (code, signal) => {
      this.child = null;
      this.flushTrailingStdoutLine();

      if (this.activeJob) {
        const active = this.activeJob;
        const error = buildClaudeCliCommandError({
          args: this.args,
          code,
          signal,
          timedOut: active.timedOut,
          stdout: active.stdout,
          stderr: active.stderr
        });
        this.failActiveJob(error);
      }

      this.pump();
    });
    child.stdin.on("error", () => {});
  }

  private terminateChild() {
    if (!this.child) return;
    const child = this.child;
    try {
      child.kill("SIGTERM");
    } catch {}
    setTimeout(() => {
      if (!child.killed) {
        try {
          child.kill("SIGKILL");
        } catch {}
      }
    }, 1000);
  }

  private handleStdoutChunk(chunk: unknown) {
    const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk || ""));
    this.stdoutRemainder += buffer.toString("utf8");

    while (true) {
      const newlineIndex = this.stdoutRemainder.indexOf("\n");
      if (newlineIndex < 0) break;
      const line = this.stdoutRemainder.slice(0, newlineIndex);
      this.stdoutRemainder = this.stdoutRemainder.slice(newlineIndex + 1);
      this.handleStdoutLine(line);
    }
  }

  private flushTrailingStdoutLine() {
    if (!this.stdoutRemainder) return;
    const trailing = this.stdoutRemainder;
    this.stdoutRemainder = "";
    this.handleStdoutLine(trailing);
  }

  private handleStdoutLine(rawLine: string) {
    const line = String(rawLine || "");
    const active = this.activeJob;
    if (!active) return;

    appendLimitedText(active, "stdout", `${line}\n`, this.maxBufferBytes);
    const parsed = safeJsonParse(line, null);
    if (!parsed || typeof parsed !== "object" || parsed.type !== "result") return;

    this.finishActiveJob();
  }

  private handleStderrChunk(chunk: unknown) {
    if (!this.activeJob) return;
    const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk || ""));
    appendLimitedText(this.activeJob, "stderr", buffer.toString("utf8"), this.maxBufferBytes);
  }

  private finishActiveJob() {
    const active = this.activeJob;
    if (!active) return;
    this.activeJob = null;
    if (active.timeout) clearTimeout(active.timeout);
    this.lastUsedAt = Date.now();
    active.resolve({
      stdout: active.stdout,
      stderr: active.stderr
    });
    this.pump();
  }

  private failActiveJob(error: unknown) {
    const active = this.activeJob;
    if (!active) return;
    this.activeJob = null;
    if (active.timeout) clearTimeout(active.timeout);

    const normalizedError = (error instanceof Error ? error : new Error(String(error || "claude CLI error"))) as ClaudeCliError;
    if (typeof normalizedError.stdout !== "string") {
      normalizedError.stdout = active.stdout;
    }
    if (typeof normalizedError.stderr !== "string") {
      normalizedError.stderr = active.stderr;
    }
    active.reject(normalizedError);
  }
}

export function createClaudeCliStreamSession({
  args,
  maxBufferBytes = 1024 * 1024
}: {
  args: string[];
  maxBufferBytes?: number;
}): ClaudeCliStreamSessionLike {
  if (!Array.isArray(args) || !args.length) {
    throw new Error("claude-code stream session requires non-empty CLI args");
  }
  return new ClaudeCliStreamSession({
    args,
    maxBufferBytes
  });
}

export function buildAnthropicImageParts(imageInputs) {
  return (Array.isArray(imageInputs) ? imageInputs : [])
    .map((image) => {
      const mediaType = String(image?.mediaType || image?.contentType || "").trim().toLowerCase();
      const base64 = String(image?.dataBase64 || "").trim();
      const url = String(image?.url || "").trim();
      if (base64 && /^image\/[a-z0-9.+-]+$/i.test(mediaType)) {
        return {
          type: "image",
          source: {
            type: "base64",
            media_type: mediaType,
            data: base64
          }
        };
      }
      if (!url) return null;
      return {
        type: "image",
        source: {
          type: "url",
          url
        }
      };
    })
    .filter(Boolean);
}

export function buildClaudeCodeStreamInput({
  contextMessages = [],
  userPrompt,
  imageInputs = [],
  turnPreamble = ""
}) {
  const events = [];

  for (const msg of Array.isArray(contextMessages) ? contextMessages : []) {
    const role = msg?.role === "assistant" ? "assistant" : "user";
    const text = String(msg?.content || "");
    events.push({
      type: role,
      message: {
        role,
        content: [{ type: "text", text }]
      }
    });
  }

  const userText = [String(turnPreamble || "").trim(), String(userPrompt || "").trim()].filter(Boolean).join("\n\n");
  const imageParts = buildAnthropicImageParts(imageInputs);
  const userContent = [{ type: "text", text: userText }, ...imageParts];
  events.push({
    type: "user",
    message: {
      role: "user",
      content: userContent
    }
  });

  return `${events.map((event) => JSON.stringify(event)).join("\n")}\n`;
}

export function buildClaudeCodeCliArgs({ model, systemPrompt = "", jsonSchema = "", maxTurns = 1 }) {
  const args = buildClaudeCodeBaseCliArgs({
    model,
    verbose: true,
    inputFormat: "stream-json",
    outputFormat: "stream-json",
    maxTurns
  });
  appendClaudeCodeOptionalCliArgs(args, { systemPrompt, jsonSchema });
  return args;
}

export function buildClaudeCodeJsonCliArgs({
  model,
  systemPrompt = "",
  jsonSchema = "",
  prompt = ""
}) {
  const args = buildClaudeCodeBaseCliArgs({
    model,
    outputFormat: "json"
  });
  appendClaudeCodeOptionalCliArgs(args, { systemPrompt, jsonSchema, prompt });
  return args;
}

export function buildClaudeCodeTextCliArgs({
  model,
  systemPrompt = "",
  jsonSchema = "",
  prompt = ""
}) {
  const args = buildClaudeCodeBaseCliArgs({ model });
  appendClaudeCodeOptionalCliArgs(args, { systemPrompt, jsonSchema, prompt });
  return args;
}

export function buildClaudeCodeFallbackPrompt({
  contextMessages = [],
  userPrompt = "",
  imageInputs = []
}) {
  const sections = [];
  const historyLines = [];
  for (const message of Array.isArray(contextMessages) ? contextMessages : []) {
    const role = message?.role === "assistant" ? "assistant" : "user";
    const text = String(message?.content || "").trim();
    if (!text) continue;
    historyLines.push(`${role}: ${text}`);
  }
  if (historyLines.length) {
    sections.push(`Conversation context:\n${historyLines.join("\n")}`);
  }

  const normalizedPrompt = String(userPrompt || "").trim();
  if (normalizedPrompt) {
    sections.push(`User request:\n${normalizedPrompt}`);
  }

  const imageLines = (Array.isArray(imageInputs) ? imageInputs : [])
    .map((image) => {
      const url = String(image?.url || "").trim();
      if (url) return `- ${url}`;

      const mediaType = String(image?.mediaType || image?.contentType || "").trim();
      const hasInlineImage = Boolean(String(image?.dataBase64 || "").trim());
      if (!hasInlineImage) return "";

      return mediaType ? `- inline image (${mediaType})` : "- inline image";
    })
    .filter(Boolean);
  if (imageLines.length) {
    sections.push(`Image references:\n${imageLines.join("\n")}`);
  }

  return sections.join("\n\n").trim();
}

export function buildClaudeCodeSystemPrompt({ systemPrompt = "", maxOutputTokens = 0 }) {
  const normalizedSystemPrompt = String(systemPrompt || "").trim();
  if (!normalizedSystemPrompt) return "";

  const requestedMaxOutputTokens = Number(maxOutputTokens || 0);
  if (!Number.isFinite(requestedMaxOutputTokens) || requestedMaxOutputTokens <= 0) {
    return normalizedSystemPrompt;
  }

  const boundedMaxOutputTokens = clampInt(maxOutputTokens, 1, 32000);

  return [
    normalizedSystemPrompt,
    `Keep the final answer under ${boundedMaxOutputTokens} tokens.`
  ].join("\n\n");
}

export function parseClaudeCodeStreamOutput(rawOutput) {
  const lines = String(rawOutput || "")
    .split(/\r?\n/g)
    .map((line) => line.trim())
    .filter(Boolean);

  let lastResult = null;
  let lastAssistantText = "";
  let lastStructuredOutputText = "";

  for (const line of lines) {
    const event = safeJsonParse(line, null);
    if (!event || typeof event !== "object") continue;

    if (event.type === "assistant" && event.message && Array.isArray(event.message.content)) {
      const textParts = [];
      for (const part of event.message.content) {
        if (part?.type === "text") {
          const textPart = String(part?.text || "").trim();
          if (textPart) textParts.push(textPart);
          continue;
        }

        if (part?.type === "tool_use" && String(part?.name || "") === "StructuredOutput") {
          const serializedOutput = serializeClaudeCodeStructuredOutput(part?.input);
          if (serializedOutput) lastStructuredOutputText = serializedOutput;
        }
      }

      const text = textParts.join("\n").trim();
      if (text) lastAssistantText = text;
      continue;
    }

    if (event.type === "result") {
      const structuredOutputText = serializeClaudeCodeStructuredOutput(event.structured_output);
      if (structuredOutputText) {
        lastStructuredOutputText = structuredOutputText;
      }
      lastResult = event;
    }
  }

  if (!lastResult) {
    const fallbackText = lastStructuredOutputText || lastAssistantText;
    if (!fallbackText) return null;
    return {
      text: fallbackText,
      isError: false,
      errorMessage: "",
      usage: { inputTokens: 0, outputTokens: 0, cacheWriteTokens: 0, cacheReadTokens: 0 },
      costUsd: 0
    };
  }

  const usage = lastResult.usage || {};
  const resultText = String(lastResult.result || "").trim();
  const preferredText = lastStructuredOutputText || resultText || lastAssistantText;

  return buildClaudeCodeParsedResult({
    result: lastResult,
    usage,
    resultText: preferredText
  });
}

function serializeClaudeCodeStructuredOutput(rawValue) {
  if (rawValue == null) return "";
  if (typeof rawValue === "string") {
    return String(rawValue || "").trim();
  }

  try {
    return JSON.stringify(rawValue);
  } catch {
    return "";
  }
}

export function parseClaudeCodeJsonOutput(rawOutput) {
  const rawText = String(rawOutput || "").trim();
  if (!rawText) return null;

  const parsedWhole = safeJsonParse(rawText, null);
  let lastResult =
    parsedWhole && typeof parsedWhole === "object" && !Array.isArray(parsedWhole)
      ? parsedWhole
      : null;

  if (!lastResult || (!lastResult.type && lastResult.result === undefined)) {
    const lines = rawText
      .split(/\r?\n/g)
      .map((line) => line.trim())
      .filter(Boolean);
    lastResult = null;
    for (const line of lines) {
      const event = safeJsonParse(line, null);
      if (!event || typeof event !== "object") continue;
      if (event.type === "result") {
        lastResult = event;
      }
    }
  }
  if (!lastResult) return null;

  const usage = lastResult.usage || {};
  const resultText =
    serializeClaudeCodeStructuredOutput(lastResult.structured_output) || String(lastResult.result || "").trim();
  return buildClaudeCodeParsedResult({
    result: lastResult,
    usage,
    resultText
  });
}

function buildClaudeCodeBaseCliArgs({
  model,
  verbose = false,
  inputFormat = "",
  outputFormat = "",
  maxTurns = 1
}) {
  const args = ["-p"];
  if (verbose) args.push("--verbose");
  args.push(
    "--no-session-persistence",
    "--strict-mcp-config",
    "--tools", ""
  );
  if (String(inputFormat || "").trim()) {
    args.push("--input-format", String(inputFormat).trim());
  }
  if (String(outputFormat || "").trim()) {
    args.push("--output-format", String(outputFormat).trim());
  }
  args.push("--model", model, "--max-turns", String(clampInt(maxTurns, 1, 10000)));
  return args;
}

function appendClaudeCodeOptionalCliArgs(args, {
  systemPrompt = "",
  jsonSchema = "",
  prompt = ""
}) {
  const normalizedSystemPrompt = String(systemPrompt || "").trim();
  if (normalizedSystemPrompt) {
    args.push("--system-prompt", normalizedSystemPrompt);
  }

  const normalizedSchema = String(jsonSchema || "").trim();
  if (normalizedSchema) {
    args.push("--json-schema", normalizedSchema);
  }

  const normalizedPrompt = String(prompt || "").trim();
  if (normalizedPrompt) {
    args.push(normalizedPrompt);
  }
}

function buildClaudeCodeParsedResult({ result, usage, resultText = "" }) {
  const errors = Array.isArray(result?.errors) ? result.errors : [];
  const normalizedResultText = String(resultText || "").trim();
  const errorMessage =
    normalizedResultText || errors.map((item) => String(item || "").trim()).filter(Boolean).join(" | ");
  return {
    text: normalizedResultText,
    isError: Boolean(result?.is_error),
    errorMessage,
    usage: {
      inputTokens: Number(usage.input_tokens || 0),
      outputTokens: Number(usage.output_tokens || 0),
      cacheWriteTokens: Number(usage.cache_creation_input_tokens || 0),
      cacheReadTokens: Number(usage.cache_read_input_tokens || 0)
    },
    costUsd: Number(result?.total_cost_usd || 0)
  };
}

export function normalizeClaudeCodeCliError(
  error,
  { timeoutPrefix = "claude-code timed out", timeoutMs = 30_000 } = {}
) {
  if (error?.killed || error?.signal === "SIGTERM") {
    return {
      isTimeout: true,
      message: `${timeoutPrefix} after ${Math.max(1, Math.floor(Number(timeoutMs) || 0) / 1000)}s.`
    };
  }

  const detail = String(error?.stderr || error?.stdout || "").trim();
  return {
    isTimeout: false,
    message: detail
      ? `claude-code CLI error: ${error?.message || error} | ${detail.slice(0, 300)}`
      : `claude-code CLI error: ${error?.message || error}`
  };
}
